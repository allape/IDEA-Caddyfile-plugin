{
  parserClass="cc.allape.caddyfile.language.parser.CaddyfileParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Caddyfile"
  psiImplClassSuffix="Impl"
  psiPackage="cc.allape.caddyfile.language.psi"
  psiImplPackage="cc.allape.caddyfile.language.psi.impl"

  elementTypeHolderClass="cc.allape.caddyfile.language.psi.CaddyfileTypes"
  elementTypeClass="cc.allape.caddyfile.CaddyfileElementType"
  tokenTypeClass="cc.allape.caddyfile.CaddyfileTokenType"

  psiImplUtilClass="cc.allape.caddyfile.CaddyfilePsiImplUtil"
}

caddyfileFile ::= item_*
private item_ ::= (property|COMMENT|CRLF)

colon ::= ":"
port_with_colon ::= colon PORT
host ::= HOSTNAME port_with_colon?

starred_hostname ::= (TEXT|STAR)(DOT (TEXT|STAR))*
starred_path ::= (SLASH? (TEXT|STAR))* SLASH?

variable ::= (LEFT_CURLY_BRACE VARIABLE_NAME RIGHT_CURLY_BRACE)

property ::= binding? group
{
  methods=[getKey getValue]
}
binding ::= (starred_hostname port_with_colon?) | port_with_colon
group ::= LEFT_CURLY_BRACE directive* RIGHT_CURLY_BRACE

directive ::=
    abort|
    acme_server|
    basic_auth|
    bind|
    encode|
    tls|
    redir|
    reverse_proxy|
    respond|

abort ::= "abort"
// not support acme_server for now
acme_server ::= "acme_server"
basic_auth ::= "basic_auth" starred_path? LEFT_CURLY_BRACE (USERNAME PASSWORD)* RIGHT_CURLY_BRACE
bind ::= "bind" (IPV4|IPV6|UNIX_SOCKET)+
encode ::= "encode" starred_path? COMPRESSION_METHOD+ (LEFT_CURLY_BRACE encode_arg* RIGHT_CURLY_BRACE)?
tls ::= "tls" FILEPATH FILEPATH
redir ::= "redir" PROTOCOL (TEXT|variable)+
respond ::= "respond" STATUS_CODE
reverse_proxy ::= "reverse_proxy" PROTOCOL host

// region encode arguments

encode_arg ::=
    encode_arg_gzip|
    encode_arg_zstd|
    encode_arg_minimum_length|
    encode_arg_match|

encode_arg_gzip ::= "gzip" GZIP_LEVEL?
encode_arg_zstd ::= "zstd"
encode_arg_minimum_length ::= "minimum_length" MINIMUM_LENGTH
encode_arg_match ::= "match" (encode_arg_match_one|encode_arg_match_two)
encode_arg_match_one ::= (("header" HEADER HEADER_VALUE?)? "|" ("status" STATUS_CODE*)?)
encode_arg_match_two ::= LEFT_CURLY_BRACE encode_arg_match_arg* RIGHT_CURLY_BRACE

encode_arg_match_arg ::= encode_arg_match_arg_status|encode_arg_match_arg_header
encode_arg_match_arg_status ::= "status" STATUS_CODE+
encode_arg_match_arg_header ::= "header" HEADER HEADER_VALUE?

// endregion
